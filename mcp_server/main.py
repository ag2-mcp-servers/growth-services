# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T03:36:32+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity
from fastapi import Header, Path, UploadFile

from models import (
    AdministrationEntityGetResponse,
    AdministrationModelEntityIdGetResponse,
    AdministrationModelGetResponse,
    AiPlanningLevelRequest,
    ForecastBottomUpResponse,
    ForecastPerformanceRequest,
    ForecastResponse,
    FullDetailsForecastResponse,
    HistoryAndForecastResponse,
    HyperparameterModel,
    JobResponse,
    JsonForecastResponse,
    LifecycleManyToOneRequest,
    LifecycleOneToOneRequest,
    MethodDto,
    NewEntityRequest,
    NewModelRequest,
    NewTokenRequest,
    NewUserRequest,
    OptimalParameterResponse,
    OutlierPostResponse,
    OutliersRequest,
    PlanningLevelDataDto,
    PlanningLevelRequest,
    PlanningLevelReRunRequest,
    PortfolioAbcPostResponse,
    PortfolioPostResponse,
    PortfolioRequest,
    PortfolioXyzPostResponse,
    ReportPerformanceSkuRationalizationPlanningLevelIdGetResponse,
    RewindResponse,
    ToggleRequest,
    ToggleUserRequest,
)

app = MCPProxy(
    title='Growth Services',
    version='v1',
)


@app.get(
    '/administration/entity',
    description=""" This is an iCUE only endpoint or Enterprise feature. """,
    tags=['organization_management'],
)
def get_administration_entity(token: Optional[str] = Header(None, alias='Token')):
    """
    Get all organizations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/administration/entity',
    description=""" This is an iCUE only endpoint or Enterprise feature. """,
    tags=['organization_management'],
)
def post_administration_entity(
    token: Optional[str] = Header(None, alias='Token'), body: NewEntityRequest = None
):
    """
    Create organization
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/administration/entity',
    description=""" This is an iCUE only endpoint or Enterprise feature. """,
    tags=['organization_management'],
)
def put_administration_entity(
    token: Optional[str] = Header(None, alias='Token'), body: ToggleRequest = None
):
    """
    Pause organization
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/administration/entity/{id}',
    description=""" This is an iCUE only endpoint or Enterprise feature. """,
    tags=['organization_management'],
)
def delete_administration_entity__id(
    id: int, token: Optional[str] = Header(None, alias='Token')
):
    """
    Delete organization
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/administration/file-to-json',
    description=""" Transform data file to JSON format """,
)
def post_administration_file_to_json(
    token: Optional[str] = Header(None, alias='Token'), file: UploadFile = ...
):
    """
    Transform data file to JSON format
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/administration/model',
    description=""" Returns models that are common for all Organizations """,
    tags=['model_management'],
)
def get_administration_model(token: Optional[str] = Header(None, alias='Token')):
    """
    Get all common Models
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/administration/model',
    description=""" Register new forecasting model for all organziations """,
    tags=['model_management', 'forecasting_operations'],
)
def post_administration_model(
    token: Optional[str] = Header(None, alias='Token'), body: NewModelRequest = None
):
    """
    Register new forecasting model
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/administration/model/{entityId}',
    description=""" Returns models registered for Organization """,
    tags=['organization_management', 'model_management'],
)
def get_administration_model__entity_id(
    entity_id: int = Path(..., alias='entityId'),
    token: Optional[str] = Header(None, alias='Token'),
):
    """
    Get Models for Organization
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/administration/model/{entityId}',
    description=""" Register new forecasting model for single organziation """,
    tags=['model_management', 'forecasting_operations'],
)
def post_administration_model__entity_id(
    entity_id: int = Path(..., alias='entityId'),
    token: Optional[str] = Header(None, alias='Token'),
    body: NewModelRequest = None,
):
    """
    Register new forecasting model
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/administration/planning-level/lock',
    description=""" Lock planning level against modification. This is an Enterprise feature. """,
    tags=['planning_level_management', 'user_management'],
)
def post_administration_planning_level_lock(
    token: Optional[str] = Header(None, alias='Token')
):
    """
    Lock planning level
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/administration/planning-level/{entityId}/{id}',
    description=""" Delete planning level. This is an Enterprise feature. """,
    tags=['planning_level_management'],
)
def delete_administration_planning_level__entity_id__id(
    entity_id: int = Path(..., alias='entityId'),
    id: int = ...,
    token: Optional[str] = Header(None, alias='Token'),
):
    """
    Delete planning level
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/administration/token',
    description=""" This is an iCUE only endpoint. """,
    tags=['token_management'],
)
def post_administration_token(
    token: Optional[str] = Header(None, alias='Token'), body: NewTokenRequest = None
):
    """
    Issue a token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/administration/user',
    description=""" Create new user for entity/organization. This can be done by entity administrator. """,
    tags=['user_management'],
)
def post_administration_user(
    token: Optional[str] = Header(None, alias='Token'), body: NewUserRequest = None
):
    """
    Create user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/administration/user', description=""" Update user """, tags=['user_management']
)
def put_administration_user(token: Optional[str] = Header(None, alias='Token')):
    """
    Update user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/administration/user/lock',
    description=""" After lock user won't be able to use iCUE API endpoints. """,
    tags=['user_management'],
)
def put_administration_user_lock(
    token: Optional[str] = Header(None, alias='Token'), body: ToggleUserRequest = None
):
    """
    Lock user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/administration/user/{entityId}',
    description=""" Get all users """,
    tags=['user_management'],
)
def get_administration_user__entity_id(
    entity_id: int = Path(..., alias='entityId'),
    token: Optional[str] = Header(None, alias='Token'),
):
    """
    Get all users
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/administration/user/{entityId}/{id}',
    description=""" Delete user """,
    tags=['user_management'],
)
def delete_administration_user__entity_id__id(
    entity_id: int = Path(..., alias='entityId'),
    id: int = ...,
    token: Optional[str] = Header(None, alias='Token'),
):
    """
    Delete user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/forecast',
    description=""" To support maximum operation and integration speed, this endpoint only returns the calculated forecast. """,
    tags=[
        'forecasting_operations',
        'forecast_result_management',
        'planning_level_management',
    ],
)
def post_forecast(
    token: Optional[str] = Header(None, alias='Token'),
    body: PlanningLevelRequest = None,
):
    """
    Forecasts only, for faster results
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/forecast/AI',
    description=""" Forecast AI is utilizing advanced machine learning models. Please be mindful of enhanced execution times (~1-2s per timeseries). """,
    tags=['forecasting_operations', 'model_management', 'hyperparameter_management'],
)
def post_forecast__a_i(
    token: Optional[str] = Header(None, alias='Token'),
    body: AiPlanningLevelRequest = None,
):
    """
    Forecast utilizing advanced machine learning models
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/forecast/AI/history-and-forecast',
    description=""" History and forecast utilizing advanced machine learning models. Please be mindful of enhanced execution times (~1-2s per timeseries). """,
    tags=['forecasting_operations', 'model_management'],
)
def post_forecast__a_i_history_and_forecast(
    token: Optional[str] = Header(None, alias='Token'),
    body: AiPlanningLevelRequest = None,
):
    """
    History and forecast utilizing advanced machine learning models
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/forecast/file-to-forecast',
    description=""" Forecast from file allows for quick analysis via Microsoft Excel and CSV file format. Please check documentation link for help. """,
    tags=['forecasting_operations', 'report_generation'],
)
def post_forecast_file_to_forecast(
    token: Optional[str] = Header(None, alias='Token'), file: UploadFile = ...
):
    """
    Forecast from file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/forecast/forecast-bottom-up',
    description=""" Calculate forecast by timeseries and sum results up to establish forecast for top level timeseries. """,
    tags=['forecasting_operations', 'planning_level_management'],
)
def post_forecast_forecast_bottom_up(
    token: Optional[str] = Header(None, alias='Token'),
    body: PlanningLevelRequest = None,
):
    """
    Bottom up forecasting
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/forecast/forecast-top-down',
    description=""" Calculate forecast based on sum of of lower level timeseries and distribute forecast down based on ratios. Great feature for planning levels with dynamic timeseries. """,
    tags=['forecasting_operations', 'planning_level_management'],
)
def post_forecast_forecast_top_down(
    token: Optional[str] = Header(None, alias='Token'),
    body: PlanningLevelRequest = None,
):
    """
    Top down forecasting
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/forecast/full-detail',
    description=""" Response provides full forecast result details, including error, trend seasonality and outlier. Great for advanced analysis. """,
    tags=['forecasting_operations', 'forecast_result_management'],
)
def post_forecast_full_detail(
    token: Optional[str] = Header(None, alias='Token'),
    body: PlanningLevelRequest = None,
):
    """
    Full forecast result details, including error, trend seasonality and outlier
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/forecast/history-and-forecast',
    description=""" Reponse provides history and forecast per timeseries. Great for visualizing results. """,
    tags=['forecasting_operations', 'report_generation'],
)
def post_forecast_history_and_forecast(
    token: Optional[str] = Header(None, alias='Token'),
    body: PlanningLevelRequest = None,
):
    """
    History and forecast for fast timeseries view
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/forecast/optimal-parameter',
    description=""" Use the optimal parameter sets created by iCUE to set the method parameters of your internal planning system. """,
    tags=['planning_level_management', 'hyperparameter_management'],
)
def post_forecast_optimal_parameter(
    token: Optional[str] = Header(None, alias='Token'),
    body: PlanningLevelRequest = None,
):
    """
    Get optimal parameter per method
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/forecast/rerun',
    description=""" Rerun previously uploaded planning level. """,
    tags=[
        'planning_level_management',
        'forecast_result_management',
        'report_generation',
    ],
)
def post_forecast_rerun(
    token: Optional[str] = Header(None, alias='Token'),
    body: PlanningLevelReRunRequest = None,
):
    """
    Rerun previously uploaded planning level
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/forecast/result/{jobId}',
    description=""" Get result for forecast job """,
    tags=['forecasting_operations', 'forecast_result_management'],
)
def get_forecast_result__job_id(
    job_id: int = Path(..., alias='jobId'),
    token: Optional[str] = Header(None, alias='Token'),
):
    """
    Forecast result
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/forecast/status/{jobId}',
    description=""" Get status for forecast job """,
    tags=['forecast_result_management', 'forecasting_operations'],
)
def get_forecast_status__job_id(
    job_id: int = Path(..., alias='jobId'),
    token: Optional[str] = Header(None, alias='Token'),
):
    """
    Forecast status
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/hyperparameter',
    description=""" Get entity global hyperparameters. """,
    tags=['hyperparameter_management', 'forecast_result_management'],
)
def get_hyperparameter(token: Optional[str] = Header(None, alias='Token')):
    """
    Get hyperparameters
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/hyperparameter',
    description=""" Set entity global hyperparameters. Hyperparameters can be overwritten by user and planning level (add to JSON body). """,
    tags=['hyperparameter_management', 'model_management'],
)
def post_hyperparameter(
    token: Optional[str] = Header(None, alias='Token'), body: HyperparameterModel = None
):
    """
    Set hyperparameters
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/inventory/amazon-ipi',
    description=""" Calculate Amazon Inventory Performance Index (IPI) """,
    tags=['inventory_management'],
)
def post_inventory_amazon_ipi(token: Optional[str] = Header(None, alias='Token')):
    """
    Calculate Amazon Inventory Performance Index (IPI)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/inventory/caryying-cost',
    description=""" Carrying Cost """,
    tags=['inventory_management'],
)
def post_inventory_caryying_cost(token: Optional[str] = Header(None, alias='Token')):
    """
    Carrying Cost
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/inventory/eoq',
    description=""" Calculate economic order quantity """,
    tags=['inventory_management'],
)
def post_inventory_eoq(token: Optional[str] = Header(None, alias='Token')):
    """
    Calculate economic order quantity
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/inventory/fill-rate',
    description=""" Calculate fill rate """,
    tags=['inventory_management', 'forecasting_operations'],
)
def post_inventory_fill_rate(token: Optional[str] = Header(None, alias='Token')):
    """
    Calculate fill rate
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/inventory/financial-imapct-forecast-accuracy',
    description=""" Calculate financial impact of forecast accuracy """,
    tags=['forecasting_operations', 'portfolio_analysis', 'report_generation'],
)
def post_inventory_financial_imapct_forecast_accuracy(
    token: Optional[str] = Header(None, alias='Token')
):
    """
    Calculate financial impact of forecast accuracy
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/inventory/inventory-turnover',
    description=""" Inventroy Turn-over """,
    tags=['inventory_management'],
)
def post_inventory_inventory_turnover(
    token: Optional[str] = Header(None, alias='Token')
):
    """
    Inventroy Turn-over
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/inventory/ltd',
    description=""" Calculate lead time demand """,
    tags=['inventory_management', 'forecasting_operations'],
)
def post_inventory_ltd(token: Optional[str] = Header(None, alias='Token')):
    """
    Calculate lead time demand
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/inventory/moq',
    description=""" Calculate minimum order quantity """,
    tags=['inventory_management'],
)
def post_inventory_moq(token: Optional[str] = Header(None, alias='Token')):
    """
    Calculate minimum order quantity
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/inventory/optimal-service-level',
    description=""" Calculate optimal service level """,
    tags=['inventory_management', 'forecasting_operations'],
)
def post_inventory_optimal_service_level(
    token: Optional[str] = Header(None, alias='Token')
):
    """
    Calculate optimal service level
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/inventory/reorder-point',
    description=""" Re-order Point """,
    tags=['inventory_management'],
)
def post_inventory_reorder_point(token: Optional[str] = Header(None, alias='Token')):
    """
    Re-order Point
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/inventory/safety-stock',
    description=""" Safety Stock """,
    tags=['inventory_management'],
)
def post_inventory_safety_stock(token: Optional[str] = Header(None, alias='Token')):
    """
    Safety Stock
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/inventory/service-level',
    description=""" Calculate service level """,
    tags=['inventory_management', 'forecasting_operations'],
)
def post_inventory_service_level(token: Optional[str] = Header(None, alias='Token')):
    """
    Calculate service level
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/inventory/turns',
    description=""" Calculate inventory turns """,
    tags=['inventory_management'],
)
def post_inventory_turns(token: Optional[str] = Header(None, alias='Token')):
    """
    Calculate inventory turns
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/lifecycle/many-to-one',
    description=""" Supports the creation of artificial startup history for new products, based on a flexible mapping of old to new. This is an Enterprise feature. """,
    tags=['lifecycle_management'],
)
def post_lifecycle_many_to_one(
    token: Optional[str] = Header(None, alias='Token'),
    body: LifecycleManyToOneRequest = None,
):
    """
    Map from old product to new product to create artifical history
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/lifecycle/one-to-one',
    description=""" Supports the creation of artificial startup history for new products, based on a flexible mapping of old to new. This is an Enterprise feature. """,
    tags=['lifecycle_management'],
)
def post_lifecycle_one_to_one(
    token: Optional[str] = Header(None, alias='Token'),
    body: LifecycleOneToOneRequest = None,
):
    """
    Map from old product to new product to create artifical history
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/outlier',
    description=""" Identify outliers (single and repetitive spikes, seasonality, masked outliers, trend and level jumps, amongst other topics) and use for cleansing of the history stream prior to forecast claculation. Depending on math model used, this approach often improves results dramatically, as it removes disturbances. """,
    tags=['forecasting_operations', 'forecast_result_management'],
)
def post_outlier(
    token: Optional[str] = Header(None, alias='Token'), body: OutliersRequest = None
):
    """
    Get outlier
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/portfolio',
    description=""" Calculate and retrieve results of ABC (pareto analysis) and xyz (Coefficient of variation) per timeseries and planning level. This analysis is a powerful means to estbalish a proper planning cadence, best accuracy messures and optimal hyperparameters for the organization. It provides a balanced and actionable overview of the entire product portfolio. """,
    tags=['portfolio_analysis'],
)
def post_portfolio(
    token: Optional[str] = Header(None, alias='Token'), body: PortfolioRequest = None
):
    """
    ABCxyz Analysis
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/portfolio/abc',
    description=""" Calculate and retrieve results of ABC (pareto analysis) per timeseries and planning level. """,
    tags=['portfolio_analysis', 'forecasting_operations'],
)
def post_portfolio_abc(
    token: Optional[str] = Header(None, alias='Token'), body: PortfolioRequest = None
):
    """
    ABC Analysis
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/portfolio/file-to-portfolio',
    description=""" Calculate and retrieve results of ABC (pareto analysis) and xyz (Coefficient of variation) per timeseries and planning level. This analysis is a powerful means to estbalish a proper planning cadence, best accuracy messures and optimal hyperparameters for the organization. It provides a balanced and actionable overview of the entire product portfolio. """,
    tags=['portfolio_analysis'],
)
def post_portfolio_file_to_portfolio(
    token: Optional[str] = Header(None, alias='Token'), file: UploadFile = ...
):
    """
    ABCxyz Analysis
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/portfolio/forecast-performance-rewind',
    description=""" Planning level rewind to calculate and measure performance potential (internal versus iCUE). """,
    tags=[
        'planning_level_management',
        'forecasting_operations',
        'report_performance_operations',
    ],
)
def post_portfolio_forecast_performance_rewind(
    token: Optional[str] = Header(None, alias='Token'),
    body: ForecastPerformanceRequest = None,
):
    """
    Planning level rewind to calculate and measure performance potential (internal versus iCUE).
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/portfolio/xyz',
    description=""" Calculate and retrieve results of xyz (Coefficient of variation) per timeseries and planning level. """,
    tags=['portfolio_analysis'],
)
def post_portfolio_xyz(
    token: Optional[str] = Header(None, alias='Token'), body: PortfolioRequest = None
):
    """
    xyz Analysis
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/pricing/bundle-pricing',
    description=""" Bundle pricing """,
    tags=['pricing_strategy'],
)
def post_pricing_bundle_pricing(token: Optional[str] = Header(None, alias='Token')):
    """
    Bundle pricing
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/pricing/competitive-pricing', tags=['token_management'])
def post_pricing_competitive_pricing(
    token: Optional[str] = Header(None, alias='Token')
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/pricing/cost-plus-pricing', tags=['token_management'])
def post_pricing_cost_plus_pricing(token: Optional[str] = Header(None, alias='Token')):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/pricing/decoy-pricing', tags=['token_management'])
def post_pricing_decoy_pricing(token: Optional[str] = Header(None, alias='Token')):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/pricing/odd-pricing', tags=['token_management'])
def post_pricing_odd_pricing(token: Optional[str] = Header(None, alias='Token')):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/pricing/penetration-pricing', tags=['token_management'])
def post_pricing_penetration_pricing(
    token: Optional[str] = Header(None, alias='Token')
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/pricing/price-elasticity-of-demand', tags=['token_management'])
def post_pricing_price_elasticity_of_demand(
    token: Optional[str] = Header(None, alias='Token')
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/report/performance/sku-rationalization/{planningLevelId}',
    description=""" SKU rationalization report """,
    tags=['report_generation', 'planning_level_management'],
)
def get_report_performance_sku_rationalization__planning_level_id(
    planning_level_id: int = Path(..., alias='planningLevelId'),
    token: Optional[str] = Header(None, alias='Token'),
):
    """
    SKU rationalization report
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/report/performance/{planningLevelId}',
    description=""" Month over month performance per planning level """,
    tags=['planning_level_management', 'report_performance_operations'],
)
def get_report_performance__planning_level_id(
    planning_level_id: str = Path(..., alias='planningLevelId'),
    token: Optional[str] = Header(None, alias='Token'),
):
    """
    Month over month performance per planning level
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/report/planning-level/organization',
    description=""" Get list of plannign levels by organization """,
    tags=['planning_level_management', 'organization_management'],
)
def get_report_planning_level_organization(
    token: Optional[str] = Header(None, alias='Token')
):
    """
    Get list of plannign levels by organization
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/report/planning-level/user',
    description=""" Get list of plannign levels by user """,
    tags=['planning_level_management', 'user_management'],
)
def get_report_planning_level_user(token: Optional[str] = Header(None, alias='Token')):
    """
    Get list of plannign levels by user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/report/user',
    description=""" Get usage statistics per user """,
    tags=['user_statistics_retrieval', 'user_management'],
)
def get_report_user(token: Optional[str] = Header(None, alias='Token')):
    """
    Get usage statistics per user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
